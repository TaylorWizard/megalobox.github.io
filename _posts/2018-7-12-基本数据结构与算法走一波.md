---
layout: post
title:  "基本数据结构与算法"
date:   2018-07-12 17:31:33 +0800
categories: js python data-structure
tags: data-structure
description: 本文从介绍大O表示法, 以及考虑每种基本算法的最好、最坏、平均复杂度以及用python和javascript两种版本来实现算法,算是弥补一下作为一个前端工程师在平时业余不会用到的基础算法与数据结构知识的空白的一个添补吧。
---

本文从介绍大O表示法, 以及考虑每种基本算法的最好、最坏、平均复杂度以及用python和javascript两种版本来实现算法,算是弥补一下作为一个前端工程师在平时业余不会用到的基础算法与数据结构知识的空白的一个添补吧。
----------------------------------

***

#### 一、大O表示法
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;大O(big-O notation), O表示(on the order of)英语翻译过来就是用来描述算法的复杂度属于什么阶的,用于表示计算机算法的效率和复杂度的一种表示法,比如O(n<sup>2</sup>)是复杂度为平方阶,O(nlogn)表示是线性对数阶复杂度。一般复杂度是由多项式的数项之和, 多项式有一个主项，例如n<sup>2</sup>-2n, 主项是n<sup>2</sup>,那么当n趋于无穷的时候, 多项式近似等于n<sup>2</sup>, 因为此时主项变得特别大,以至于可以忽略其他项

#### 二、快速排序
- ##### 复杂度分析
  - 最好情况
    $$ O(n\log n)  $$
  - 最坏情况
  $$ O(n^2) $$
  - 平均情况
  $$ O(n\log n)  $$
- python version
  {% highlight python %}
    def quicksort(lyst):
        quickSortHelper(lyst, 0, len(lyst) - 1)

    def quickSortHelper(lyst, left, right):
        if left < right:
            pivotLocation = partition(lyst, left ,right)
            quickSortHelper(lyst, left, pivotLocation - 1)
            quickSortHelper(lyst, pivotLocation + 1, right)

    def partition(lyst, left, right):
        middle = (left + right) // 2
        pivot = lyst[middle]
        lyst[middle] = lyst[right]
        lyst[right] = pivot
        boundary = left
        for index in range(left, right):
            if lyst[index] < pivot:
                lyst[index], lyst[boundary] = lyst[boundary], lyst[index]
                boundary += 1
        lyst[boundary], lyst[right] = lyst[right], lyst[boundary]
        return boundary

    import random

    def main (size = 20, sort = quicksort):
        lyst = []
        for count in range(size):
            lyst.append(random.randint(1, size + 1))
        print(lyst)
        sort(lyst)
        print(lyst)

    if __name__ == '__main__':
        main()
  {% endhighlight %}
- javascript version
  {% highlight javascript %}
      class Quicksort {
        constructor(array) {
            if (array.length <= 1) return array;
            this.array = array;
            this.len = array.length;
            Quicksort.quicksortHelper(this.array, 0, this.len - 1);
        }

        static partition(array, left, right) {
            let middle = ~~ ((left + right) / 2);
            let pivot = array[middle];
            [array[middle], array[right]] = [array[right], array[middle]];
            let boundary = left;
            for (let i = left; i < right; i += 1) {
                if (array[i] < pivot) {
                    [array[i], array[boundary]] = [array[boundary], array[i]];
                    boundary += 1;
                }
            }
            [array[boundary], array[right]] = [array[right], array[boundary]];
            return boundary;
        }

        static quicksortHelper(array, left ,right) {
            if (left < right) {
                const pivotLocation = Quicksort.partition(array, left, right);
                Quicksort.quicksortHelper(array, left, pivotLocation - 1);
                Quicksort.quicksortHelper(array, pivotLocation + 1, right);
            }
        }
    }

    function init(size = 20) {
        let arr = [];
        for(let i = 0; i < size; i++) {
            arr.push(~~(Math.random() * (size + 10)));
        }
        console.log(arr);
        const quicksort = new Quicksort(arr);
        console.log(arr);
    }

    init()
   {% endhighlight %}

markdown[^1]
[^1]: adsfasdf