---
layout: post
title:  "基本数据结构与算法"
date:   2018-07-12 17:31:33 +0800
categories: js python data-structure
tags: data-structure
description: 本文从介绍大O表示法, 以及考虑每种基本算法的最好、最坏、平均复杂度以及用python和javascript两种版本来实现算法,算是弥补一下作为一个前端工程师在平时业余不会用到的基础算法与数据结构知识的空白的一个添补吧。
---

本文从介绍大O表示法, 以及考虑每种基本算法的最好、最坏、平均复杂度以及用python和javascript两种版本来实现算法,算是弥补一下作为一个前端工程师在平时业余不会用到的基础算法与数据结构知识的空白的一个添补吧。
----------------------------------

***

#### 一、大O表示法
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;大O(big-O notation), O表示(on the order of)英语翻译过来就是用来描述算法的复杂度属于什么阶的,用于表示计算机算法的效率和复杂度的一种表示法,比如O(n<sup>2</sup>)是复杂度为平方阶,O(nlogn)表示是线性对数阶复杂度。一般复杂度是由多项式的数项之和, 多项式有一个主项，例如n<sup>2</sup>-2n, 主项是n<sup>2</sup>,那么当n趋于无穷的时候, 多项式近似等于n<sup>2</sup>, 因为此时主项变得特别大,以至于可以忽略其他项

#### 二、快速排序
- ##### 复杂度分析
  - 最好情况
    > 
  - 最坏情况
  - 平均情况
  $$ x = \dfrac{\Sigma t^2}{N/4} $$
- python version
  {% highlight python %}
    def partition(nums,left,right):
    key = nums[left]
    while left < right:
        # right下标位置开始，向左边遍历，查找不大于基准数的元素
        while left < right and nums[right] >= key:
            right -= 1
        if left < right:  # 找到小于准基数key的元素,然后交换nums[left],nums[right]
            nums[left],nums[right] = nums[right],nums[left]
        else:   # left〉=right 跳出循环
            break
        # left下标位置开始，向右边遍历，查找不小于基准数的元素
        while left < right and nums[left] < key:
            left += 1
        if left < right:  # 找到比基准数大的元素，然后交换nums[left],nums[right]
            nums[right],nums[left] = nums[left],nums[right]
        else: # left〉=right 跳出循环
            break
    return left  #此时left==right 所以返回right也是可以的

    def quick_sort_standord(nums,left,right):
        if left < right:
            key_index = partition(nums,left,right)
            quick_sort_standord(nums,left,key_index)
            quick_sort_standord(nums,key_index+1,right)

    if __name__ == '__main__':
        nums = [5, 6, 4, 2, 3,1]
        print (nums)
        quick_sort_standord(nums,0,len(nums)-1)
        print (nums)
  {% endhighlight %}
- javascript version
  ```
  ```

markdown[^1]
[^1]: adsfasdf