---
layout: post
title:  "基本数据结构与算法"
date:   2018-07-12 17:31:33 +0800
categories: js python data-structure
tags: data-structure
description: 本文从介绍大O表示法, 以及考虑每种基本算法的最好、最坏、平均复杂度以及用python和javascript两种版本来实现算法,算是弥补一下作为一个前端工程师在平时业余不会用到的基础算法与数据结构知识的空白的一个添补吧。
---

**本文从介绍大O表示法, 以及考虑每种基本算法的最好、最坏、平均复杂度以及用python和javascript两种版本来实现算法,算是弥补一下作为一个前端工程师在平时业余不会用到的基础算法与数据结构知识的空白的一个添补吧。**

---

#### 大O表示法
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;大O(big-O notation), O表示(on the order of)英语翻译过来就是用来描述算法的复杂度属于什么阶的,用于表示计算机算法的效率和复杂度的一种表示法,比如O(n<sup>2</sup>)是复杂度为平方阶,O(nlogn)表示是线性对数阶复杂度。一般复杂度是由多项式的数项之和, 多项式有一个主项，例如n<sup>2</sup>-2n, 主项是n<sup>2</sup>,那么当n趋于无穷的时候, 多项式近似等于n<sup>2</sup>, 因为此时主项变得特别大,以至于可以忽略其他项
 
-----

**本人会对典型的排序做详细的分析，其余与其相似的算法会简略讲解和给出具体代码实现。**

-----

#### 快速排序
- ##### 快速排序每次递归会将数组两两分割,基准点左边的数小于基准点，基准点右边的数大于基准点。
- ##### 如何将数组分割
    1. 选择一个基准点，这里我们为了方便起见假设数组居中的值为基准点。
    
    2. 在已知小于基准点的项和剩余的项之间建立一个边界，一开始这个边界就放在第一项之前。
    
    3. 从子列表的第一项开始,扫描整个子列表，每次遇到小于基准点的项，就将其与边界后的第一项进行交换, 然后将边界向后移动一位。
    
    4. 将基准点与边界后的第一项进行交换。
    
- ##### 用表格描述分割一个子列表的过程

  |假设列表为右侧列出的列表,有一个基准点18| 12，19，17，<span style="color:red;">13</span>，14，11，15
  --|--|--
  |将基准点与子列表最后一项进行交换,并且将边界设在第一项之前|<span style="display:inline-block;text-align:center;width:10px;background-color:#c0c0c0">:</span> 12, 19, 17, <span style="color:red;">15</span>, 14, 11, <span style="color:red;">13</span>
  |扫描小于基准点的项|<span style="display:inline-block;text-align:center;width:10px;background-color:#c0c0c0">:</span> <span style="color:red;">12</span>, 19, 17, 15, 14, 11, 13
  |将小于基准点的这一项和边界后的第一项交换,这次是自身交换,并将边界往后移动一位|<span style="color:red;">12</span> <span style="display:inline-block;text-align:center;width:10px;background-color:#c0c0c0">:</span> 19, 17, 15, 14, 11, 13
  |继续扫描边界往后小于基准点的项, 11小于基准点，将11与边界后一项交换,此时边界往后移动一位|12, <span style="color:red;">11 </span><span style="display:inline-block;text-align:center;width:10px;background-color:#c0c0c0">:</span> 19, 17, 15, 14, 13
  |继续扫描,已经没有小于基准点的项,结束本次子列表扫描|12, 11 <span style="display:inline-block;text-align:center;width:10px;background-color:#c0c0c0">:</span> 19, 17, 15, 14, 13
  |最后将基准点与边界后一项进行交换|12, 11 <span style="display:inline-block;text-align:center;width:10px;background-color:#c0c0c0">:</span> <span style="color:red">13</span>, 17, 15, 14, <span style="color:red;">19</span>

  - **重复以上过程,继续划分子列表(12,11)(19,17,15,14,19,13), 直到子列表长度为1**

- ##### 复杂度分析
  - 最好情况
    $$ O(n\log n)  $$
  - 最坏情况
  $$ O(n^2) $$
  - 平均情况
  $$ O(n\log n)  $$
- python version
  {% highlight python %}
    def quicksort(lyst):
        quickSortHelper(lyst, 0, len(lyst) - 1)

    def quickSortHelper(lyst, left, right):
        if left < right:
            pivotLocation = partition(lyst, left ,right)
            quickSortHelper(lyst, left, pivotLocation - 1)
            quickSortHelper(lyst, pivotLocation + 1, right)

    def partition(lyst, left, right):
        middle = (left + right) // 2
        pivot = lyst[middle]
        lyst[middle] = lyst[right]
        lyst[right] = pivot
        boundary = left
        for index in range(left, right):
            if lyst[index] < pivot:
                lyst[index], lyst[boundary] = lyst[boundary], lyst[index]
                boundary += 1
        lyst[boundary], lyst[right] = lyst[right], lyst[boundary]
        return boundary

    import random

    def main (size = 20, sort = quicksort):
        lyst = []
        for count in range(size):
            lyst.append(random.randint(1, size + 1))
        print(lyst)
        sort(lyst)
        print(lyst)

    if __name__ == '__main__':
        main()
  {% endhighlight %}
- javascript version
  {% highlight javascript %}
      class Quicksort {
        constructor(array) {
            if (array.length <= 1) return array;
            this.array = array;
            this.len = array.length;
            Quicksort.quicksortHelper(this.array, 0, this.len - 1);
        }

        static partition(array, left, right) {
            let middle = ~~ ((left + right) / 2);
            let pivot = array[middle];
            [array[middle], array[right]] = [array[right], array[middle]];
            let boundary = left;
            for (let i = left; i < right; i += 1) {
                if (array[i] < pivot) {
                    [array[i], array[boundary]] = [array[boundary], array[i]];
                    boundary += 1;
                }
            }
            [array[boundary], array[right]] = [array[right], array[boundary]];
            return boundary;
        }

        static quicksortHelper(array, left ,right) {
            if (left < right) {
                const pivotLocation = Quicksort.partition(array, left, right);
                Quicksort.quicksortHelper(array, left, pivotLocation - 1);
                Quicksort.quicksortHelper(array, pivotLocation + 1, right);
            }
        }
    }

    function init(size = 20) {
        let arr = [];
        for(let i = 0; i < size; i++) {
            arr.push(~~(Math.random() * (size + 10)));
        }
        console.log(arr);
        const quicksort = new Quicksort(arr);
        console.log(arr);
    }

    init()
   {% endhighlight %}

#### 归并排序